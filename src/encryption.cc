#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <math.h>

#include <sys/types.h>
#include <sys/socket.h>

#include <openssl/evp.h>
#include <openssl/aes.h>
#include <openssl/err.h>
#include <openssl/engine.h>

#include "logger.h"
#include "types.hpp"

#include "encryption.hpp"

/**
 * @brief File contains definitions of supporting functionality to encrypt and decrypt data
 * @author Salih MSA
 */


extern unsigned int OPENSSL_ia32cap_P[] ;
extern void OPENSSL_cpuid_setup() ;


namespace {
W
	/* below is (mod)Power function to return value of a ^ b mod c
	 * we use it twice so i've just conveniently made it a callable yet inliner here */
	static inline razan::key_t modpow(const razan::key_t a, const razan::key_t b, const razan::key_t c) noexcept
	{
		if(b == 1)
		{
			return a ;
		}

		razan::key_t ret ;
		pow(reinterpret_cast<(*a.data()), b.data()) % c ;
	}

} // ~ namespace


razan::key_t razan::generate_random_number() noexcept
{
	int status ;
	razan::key_t random_number ;

	OPENSSL_add_all_algorithms_noconf() ; /* This is called by OPENSSL_load_builtin_engines() */

	status = OPENSSL_ia32cap_P[1] & (1 << (62 - 32)) ;
	if(!status)
	{
		printl(REPORT, "rdrand is not available") ;
		abort() ;
	}

	ENGINE_load_rdrand() ; /* Load the engine of interest */
	ENGINE* eng1 = ENGINE_by_id("rdrand") ; /* used for ENGINE_finish */
	if(!eng1)
	{
		const unsigned long err_code = ERR_get_error() ;
		const char* err = ERR_error_string(err_code, NULL) ;
		printl(REPORT, "ENGINE_load_rdrand failed (err #0x%lx, %s)", err_code, err) ;
		abort() ;
	}

	ENGINE* eng2 = eng1 ; /* Make the assignment for proper cleanup (ENGINE_by_id needs one cleanup, ENGINE_init needs a second distinct cleanup) */ /* used for ENGINE_free */
	status = ENGINE_init(eng2) ;
	if(!status)
	{
		const unsigned long err_code = ERR_get_error() ;
		const char* err = ERR_error_string(err_code, NULL) ;
		printl(REPORT, "ENGINE_init failed (err #0x%lx, %s)", err_code, err) ;
		abort() ;
	}

	status = ENGINE_set_default(eng2, ENGINE_METHOD_RAND) ; /* Set the default RAND_method */
	if(!status)
	{
		const unsigned long err_code = ERR_get_error() ;
		const char* err = ERR_error_string(err_code, NULL) ;
		printl(REPORT, "ENGINE_set_default failed (err #0x%lx, %s)", err_code, err) ;
		abort() ;
	}

	status = RAND_bytes(reinterpret_cast<unsigned char*>(&random_number), sizeof(key_t)) ;
	if(!status) {
		const unsigned long err_code = ERR_get_error() ;
		const char* err = ERR_error_string(err_code, NULL) ;
		printl(REPORT, "RAND_bytes (1) failed (err #0x%lx, %s)", err_code, err) ;
		abort() ;
	}

	printl(DEBUG, "Generated bytes: %llu (in function %s, file %s)", random_number, __func__, __FILE__) ;

	if(eng1)
		ENGINE_free(eng1) ;
	if(eng2)
		ENGINE_finish(eng2) ;
	ENGINE_cleanup() ;

	return random_number ;
}


std::tuple<razan::key_t, razan::key_t> razan::generate_public_keys() noexcept
{
	const auto p_key = generate_random_number() ;
	const auto g_key = 9 ;

	return {p_key, g_key} ;
}


std::tuple<razan::key_t, razan::key_t> razan::generate_secret_keys(const key_t& p_key, const key_t& g_key) noexcept
{
	const auto priv_key = generate_random_number() ;
	const auto mashed_key = modpow(g_key, priv_key, p_key) ;

	return {priv_key, mashed_key} ;
}


razan::key_t razan::generate_symmetric_key(const razan::key_t& their_mashed_key, const razan::key_t& my_private_key, const razan::key_t& prime_public) noexcept
{
	return modpow(their_mashed_key, my_private_key, prime_public) ;
}


razan::msg_t razan::encrypt(const EncryptionDetails& enc_details, const razan::msg_t& plain_txt) noexcept
{
	razan::msg_t cipher_txt(std::ceil(plain_txt.size() / AES_BLOCK_SIZE) * AES_BLOCK_SIZE, '\0') ; // initialise buffer to be *at least* size of
	const auto ctcstr = reinterpret_cast<unsigned char*>(cipher_txt.data()) ;

	EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new() ; /* Create and initialise the context */
	if(!ctx)
	{
		const unsigned long err_code = ERR_get_error() ;
		const char* err = ERR_error_string(err_code, NULL) ;
		printl(REPORT, "Creating encryption context failed (err #0x%lx, %s)", err_code, err) ;
		abort() ;
	}

	if(!EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, reinterpret_cast<const unsigned char*>(&enc_details.key), reinterpret_cast<const unsigned char*>(&enc_details.iv)))
	{ /* Initialise the encryption operation. 256 bit AES key, IV size same as the block size- 128 bits */
		const unsigned long err_code = ERR_get_error() ;
		const char* err = ERR_error_string(err_code, NULL) ;
		printl(REPORT, "Initialising encryption failed (err #0x%lx, %s)", err_code, err) ;
		abort() ;
	}

	int len ;
	if(!EVP_EncryptUpdate(ctx, ctcstr, &len, reinterpret_cast<const unsigned char*>(plain_txt.c_str()), plain_txt.size()))
	{ /* Provide the message to be encrypted, and obtain the encrypted output. EVP_EncryptUpdate can be called multiple times if necessary */
		const unsigned long err_code = ERR_get_error() ;
		const char* err = ERR_error_string(err_code, NULL) ;
		printl(REPORT, "Encrypting bytes failed (err #0x%lx, %s)", err_code, err) ;
		abort() ;
	}

	if(!EVP_EncryptFinal_ex(ctx, ctcstr + len, &len))
	{ /* Finalise the encryption. Further ciphertext bytes may be written at this stage */
		const unsigned long err_code = ERR_get_error() ;
		const char* err = ERR_error_string(err_code, NULL) ;
		printl(REPORT, "Finalising encryption (of partial block bytes) failed (err #0x%lx, %s)", err_code, err) ;
		abort() ;
	}

	printl(DEBUG, "Encryption finalised (in function %s, file %s)", __func__, __FILE__) ;
	EVP_CIPHER_CTX_free(ctx) ; /* Clean up */
	return cipher_txt ;
}


razan::msg_t razan::decrypt(const EncryptionDetails& enc_details, const razan::msg_t& cipher_txt) noexcept
{
	razan::msg_t plain_txt(cipher_txt.size(), '\0') ; // initialise buffer to be *at least* size of
	const auto ptcstr = reinterpret_cast<unsigned char*>(plain_txt.data()) ;

	printl(DEBUG, "Message to be decrypted. String: %s (in function %s, file %s)", cipher_txt.c_str(), __func__, __FILE__) ;

	EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new() ; /* Create and initialise the context */
	if(!ctx)
	{
		const unsigned long err_code = ERR_get_error() ;
		const char* err = ERR_error_string(err_code, NULL) ;
		printl(REPORT, "Creating encryption context failed (err #0x%lx, %s)", err_code, err) ;
		abort() ;
	}

	if(!EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, reinterpret_cast<const unsigned char*>(&enc_details.key), reinterpret_cast<const unsigned char*>(&enc_details.iv)))
	{ /* Initialise the decryption operation */
		const unsigned long err_code = ERR_get_error() ;
		const char* err = ERR_error_string(err_code, NULL) ;
		printl(REPORT, "Initialising decryption failed (err #0x%lx, %s)", err_code, err) ;
		abort() ;
	}
	printl(DEBUG, "Initialisation of decryption done (in function %s, file %s)", __func__, __FILE__) ;

	int len ;
	if(!EVP_DecryptUpdate(ctx, ptcstr, &len, reinterpret_cast<const unsigned char*>(cipher_txt.c_str()), cipher_txt.size()))
	{ /* Provide the message to be decrypted, and obtain the plaintext output. EVP_DecryptUpdate can be called multiple times if necessary */
		const unsigned long err_code = ERR_get_error() ;
		const char* err = ERR_error_string(err_code, NULL) ;
		printl(REPORT, "Decrypting bytes failed (err #0x%lx, %s)", err_code, err) ;
		abort() ;
	}
	printl(DEBUG, "Message successfully decrypted. String: %s (in function %s, file %s)", plain_txt.c_str(), __func__, __FILE__) ;

	if(!EVP_DecryptFinal_ex(ctx, ptcstr + len, &len))
	{ /* Finalise the decryption. Further plaintext bytes may be written at this stage */
		const unsigned long err_code = ERR_get_error() ;
		const char* err = ERR_error_string(err_code, NULL) ;
		printl(REPORT, "Finalising decryption (of partial block bytes) failed (err #0x%lx, %s)", err_code, err) ;
		abort() ;
	}

	printl(DEBUG, "Decryption finalised (in function %s, file %s)", __func__, __FILE__) ;
	EVP_CIPHER_CTX_free(ctx) ; /* Clean up */
	return plain_txt ;
}
