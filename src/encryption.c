#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <math.h>
#include <assert.h>

#include <sys/types.h>
#include <sys/socket.h>

#include <openssl/evp.h>
#include <openssl/aes.h>
#include <openssl/err.h>
#include <openssl/engine.h>

#include "encryption.h"

extern unsigned int OPENSSL_ia32cap_P[] ;
extern void OPENSSL_cpuid_setup(void) ;

/** @brief File contains declarations of supporting functionality to encrypt and decrypt data **/

void text_data_init(struct TextData* txt)
{
    #define MSG_LENGTH 100
    txt->max_len = MSG_LENGTH ;

    txt->plain_text_len = 0 ;
    txt->plain_text = malloc(sizeof(unsigned char) * txt->max_len) ;
    memset(txt->plain_text, '\0', txt->max_len) ;

    txt->cipher_text_len = 0 ;
    txt->cipher_text = malloc(sizeof(unsigned char) * txt->max_len) ;
    memset(txt->cipher_text, '\0', txt->max_len) ;
    #undef MSG_LENGTH
}

void text_data_grow(struct TextData* txt)
{
    txt->max_len *= 2 ;
    txt->plain_text = realloc(txt->plain_text, txt->max_len) ;
    assert(txt->plain_text) ;
    memset(txt->plain_text + (txt->max_len/2), '\0', txt->max_len / 2) ;
    txt->plain_text = realloc(txt->cipher_text, txt->max_len) ;
    assert(txt->cipher_text) ;
    memset(txt->cipher_text + (txt->max_len/2), '\0', txt->max_len / 2) ;
}

void text_data_fini(struct TextData* txt)
{
    free(txt->plain_text) ;
    free(txt->cipher_text) ;
}

void encryption_details_init(struct EncryptionDetails* enc_details)
{
    #define KEY_LENGTH sizeof(unsigned long long)
    enc_details->enc_len = KEY_LENGTH ;
    enc_details->key = malloc(sizeof(unsigned char) * enc_details->enc_len) ;
    enc_details->iv = malloc(sizeof(unsigned char) * enc_details->enc_len) ;
    #undef KEY_LENGTH
}

void encryption_details_fini(struct EncryptionDetails* enc_details)
{
    enc_details->enc_len = 0 ;
    free(enc_details->key) ;
    free(enc_details->iv) ;
}

unsigned long long int generate_random_number(void)
{
    unsigned long err ;
    int status ;

    // This is called by OPENSSL_load_builtin_engines()
    OPENSSL_cpuid_setup() ;

    // These point to the same engine. One is used for ENGINE_finish, and the other is used for ENGINE_free.
    ENGINE* eng1 = NULL ;
    ENGINE* eng2 = NULL ;

    status = OPENSSL_ia32cap_P[1] & (1<<(62-32)) ;
    if(!status)
    {
        fprintf(stderr, "rdrand is not available\n") ;
        abort() ;
    }

    /* Load the engine of interest */
    ENGINE_load_rdrand() ;
    eng1 = ENGINE_by_id("rdrand") ;
    err = ERR_get_error() ;
    if(!eng1)
    {
        fprintf(stderr, "ENGINE_load_rdrand failed, err = 0x%lx\n", err) ;
        abort() ; /* failed */
    }

    // Make the assignment for proper cleanup (ENGINE_by_id needs one cleanup, ENGINE_init needs a second distinct cleanup).
    status = ENGINE_init( (eng2 = eng1) ) ;
    err = ERR_get_error() ;
    if(!status)
    {
        fprintf(stderr, "ENGINE_init failed, err = 0x%lx\n", err) ;
        abort() ; /* failed */
    }

    /* Set the default RAND_method */
    status = ENGINE_set_default(eng2, ENGINE_METHOD_RAND) ;
    err = ERR_get_error() ;
    if(!status)
    {
        fprintf(stderr, "ENGINE_set_default failed, err = 0x%lx\n", err) ;
        abort() ; /* failed */
    }

    unsigned long long random_number ;
    status = RAND_bytes((unsigned char*)&random_number, sizeof(random_number)) ;
    err = ERR_get_error() ;
    if(!status)
    {
        fprintf(stderr, "RAND_bytes (1) failed, err = 0x%lx\n", err) ;
        abort() ; /* failed */
    }

    fprintf(stdout, "Generated bytes: %llu\n", random_number) ;

    if(eng1) ENGINE_free(eng1) ;
    if(eng2) ENGINE_finish(eng2) ;
    ENGINE_cleanup() ;

    return random_number ; 
}

struct TwoKeys generate_public_keys(void)
{
    const unsigned long long P = generate_random_number() ;
    const unsigned long long G = 9 ;

    struct TwoKeys public_keys = {P, G} ; ;
    return public_keys ;
}

static inline unsigned long long modpow(long long int a, long long int b, long long int P) // Power function to return value of a ^ b mod P
{
    if(b == 1)
    {
        return a ;
    }
    return (((unsigned long long)pow(a, b)) % P) ;
}

struct TwoKeys generate_secret_keys(const struct TwoKeys* public_keys)
{
    const unsigned long long private_key = generate_random_number() ;
    const unsigned long long mashed_key = modpow(public_keys->key_b, private_key, public_keys->key_a) ; // mash up private key to create a secret key

    struct TwoKeys secret_keys = {private_key, mashed_key} ;
    return secret_keys ;
}

unsigned long long generate_symmetric_key(const unsigned long long their_mashed_key, const unsigned long long my_private_key, const unsigned long long prime_public)
{
    const unsigned long long symmetric_key = modpow(their_mashed_key, my_private_key, prime_public) ;
    return symmetric_key ;
}

struct EncryptionDetails encryption_setup(const int end_point_socket, const enum USER_t rank)
{
    fprintf(stdout, "logg1\n") ;
    struct TwoKeys public_keys ;
    if(rank == CLIENT)
    {
        fprintf(stdout, "logg2\n") ;
        read(end_point_socket, &public_keys, sizeof(struct TwoKeys)) ;
    }
    else { // server
        fprintf(stdout, "logg3\n") ;
        public_keys = generate_public_keys() ;
        send(end_point_socket, &public_keys, sizeof(struct TwoKeys), 0) ;
    }

    const struct TwoKeys secret_keys = generate_secret_keys(&public_keys) ;
    send(end_point_socket, &(secret_keys.key_b), sizeof(secret_keys.key_b), 0) ; // send mashed key to other side

    unsigned long long her_mashed_key ;
    read(end_point_socket, &her_mashed_key, sizeof(her_mashed_key)) ; // read in other clients mashed key

    struct EncryptionDetails enc_details ;
    encryption_details_init(&enc_details) ;
    *enc_details.key = generate_symmetric_key(her_mashed_key, secret_keys.key_a, public_keys.key_a) ; // actual key
    *enc_details.iv = 1 ; // actual key

    return enc_details ;
}

static inline void handle_errors(void)
{
    const unsigned long errCode = ERR_get_error() ;
    const char* err = ERR_error_string(errCode, NULL) ;
    fprintf(stderr, "Error: %s\n", err) ;
    abort() ;
}

void encrypt(const struct EncryptionDetails* enc_details, struct TextData* txt)
{
    EVP_CIPHER_CTX *ctx;

    /* Create and initialise the context */
    if(!(ctx = EVP_CIPHER_CTX_new()))
        handle_errors();

    /*
     * Initialise the encryption operation. IMPORTANT - ensure you use a key
     * and IV size appropriate for your cipher
     * In this example we are using 256 bit AES (i.e. a 256 bit key). The
     * IV size for *most* modes is the same as the block size. For AES this
     * is 128 bits
     */
    if(1 != EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, enc_details->key, enc_details->iv))
        handle_errors();

    /*
     * Provide the message to be encrypted, and obtain the encrypted output.
     * EVP_EncryptUpdate can be called multiple times if necessary
     */
    int len ;
    if(1 != EVP_EncryptUpdate(ctx, txt->cipher_text, &len, txt->plain_text, txt->plain_text_len))
        handle_errors() ;
    txt->cipher_text_len = len ;

    /*
     * Finalise the encryption. Further ciphertext bytes may be written at
     * this stage.
     */
    if(1 != EVP_EncryptFinal_ex(ctx, (unsigned char*)(txt->cipher_text + len), &len))
        handle_errors();
    txt->cipher_text_len += len;

    /* Clean up */
    EVP_CIPHER_CTX_free(ctx);
}

void decrypt(const struct EncryptionDetails* enc_details, struct TextData* txt)
{
    EVP_CIPHER_CTX *ctx ;

    /* Create and initialise the context */
    if(!(ctx = EVP_CIPHER_CTX_new()))
        handle_errors();

    /*
     * Initialise the decryption operation. IMPORTANT - ensure you use a key
     * and IV size appropriate for your cipher
     * In this example we are using 256 bit AES (i.e. a 256 bit key). The
     * IV size for *most* modes is the same as the block size. For AES this
     * is 128 bits
     */
    if(1 != EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, enc_details->key, enc_details->iv))
        handle_errors();

    /*
     * Provide the message to be decrypted, and obtain the plaintext output.
     * EVP_DecryptUpdate can be called multiple times if necessary.
     */
    int len ;
    if(1 != EVP_DecryptUpdate(ctx, txt->plain_text, &len, txt->cipher_text, txt->cipher_text_len))
        handle_errors();
    txt->plain_text_len = len;

    /*
     * Finalise the decryption. Further plaintext bytes may be written at
     * this stage.
     */
    if(1 != EVP_DecryptFinal_ex(ctx, (unsigned char*)(txt->plain_text + len), &len))
        handle_errors();
    txt->plain_text_len += len;

    /* Clean up */
    EVP_CIPHER_CTX_free(ctx);
}
